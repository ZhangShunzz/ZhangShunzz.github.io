---
layout: post
title:  Jvm 性能调优监控工具 
date:   2018-11-27 16:25:00 +0800
categories: 技术
tag: Jvm/tomcat
---


##### jstat #####
---
**jstat主要用来输出JVM中的内存使用信息和垃圾回收统计。**

1.jstat -gc xxx<br>

|  显示列名	 | 具体描述  |
|  :-:  | :----:  |
| S0C  | 年轻代中第一个survivor（幸存区）的容量 (字节) |
| S1C  | 年轻代中第二个survivor（幸存区）的容量 (字节) |
| S0U  | 年轻代中第一个survivor（幸存区）目前已使用空间 (字节) |
| S1U  | 年轻代中第二个survivor（幸存区）目前已使用空间 (字节) |
| EC  | 年轻代中Eden（伊甸园）的容量 (字节) |
| EU  | 年轻代中Eden（伊甸园）目前已使用空间 (字节) |
| OC  | Old代的容量 (字节) |
| OU  | Old代目前已使用空间 (字节) |
| MC  | 方法区(持久代)的容量 (字节) |
| MU  | 方法区(持久代)目前已使用空间 (字节) |
| CCSC  | 压缩类空间大小 |
| CCSU  | 压缩类空间使用大小 |
| YGC  | 从应用程序启动到采样时年轻代中gc次数 |
| YGCT  | 从应用程序启动到采样时年轻代中gc所用时间(s) |
| FGC  | 从应用程序启动到采样时old代(全gc)gc次数 |
| FGCT  | 从应用程序启动到采样时old代(全gc)gc所用时间(s) |
| GCT  | 从应用程序启动到采样时gc用的总时间(s) |

2.jstat -gcutil xxx<br>

|  显示列名   | 具体描述  |
|  :-:  | :----:  |
| S0  | 幸存1区当前使用比例 |
| S1  | 幸存2区当前使用比例 |
| E  | 伊甸园区使用比例 |
| O  | 老年代使用比例 |
| M  | 元数据区使用比例(方法区) |
| CCS  | 压缩使用比例 |
| YGC  | 年轻代垃圾回收次数 |
| FGC  | 老年代垃圾回收次数 |
| FGCT  | 老年代垃圾回收消耗时间 |
| GCT  | 垃圾回收消耗总时间 |

  

##### jstack
---
**jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：**

    jstack [option] pid
    
    -l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况
    
    -m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）

 jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。

步骤：

    1. ps -ef | grep java		#查看进程id
    2. top -Hp pid		#找出该进程内最耗费CPU的线程id
    3. printf "%x\n" $线程id			#得到十六进制值
    4. jstack pid | grep $十六进制值		#可以看到CPU消耗在的代码块，研发修改代码

 - RUNNABLE,在虚拟机内执行的。运行中状态，可能里面还能看到locked字样，表明它获得了某把锁。
 - BLOCKED,受阻塞并等待监视器锁。被某个锁(synchronizers)給block住了。
 - WATING,无限期等待另一个线程执行特定操作。等待某个condition或monitor发生，一般停留在park(), wait(), sleep(),join() 等语句里。
 - TIMED_WATING,有时限的等待另一个线程的特定操作。和WAITING的区别是wait() 等语句加上了时间限制 wait(timeout)。
 - TERMINATED,已退出的。

