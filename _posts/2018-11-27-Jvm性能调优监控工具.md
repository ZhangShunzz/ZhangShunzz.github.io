---
layout: post
title:  Jvm 性能调优监控工具 
date:   2018-11-27 16:25:00 +0800
categories: 技术
tag: Jvm/tomcat
---


##### jstat
---
**jstat主要用来输出JVM中运行的进程状态信息。**

1. jstat -gc xxx

B、 jstack
---
**jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：**

    jstack [option] pid
    
    -l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况
    
    -m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）

 jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。

步骤：

    1. ps -ef | grep java		#查看进程id
    2. top -Hp pid		#找出该进程内最耗费CPU的线程id
    3. printf "%x\n" $线程id			#得到十六进制值
    4. jstack pid | grep $十六进制值		#可以看到CPU消耗在的代码块，研发修改代码

 - RUNNABLE,在虚拟机内执行的。运行中状态，可能里面还能看到locked字样，表明它获得了某把锁。
 - BLOCKED,受阻塞并等待监视器锁。被某个锁(synchronizers)給block住了。
 - WATING,无限期等待另一个线程执行特定操作。等待某个condition或monitor发生，一般停留在park(), wait(), sleep(),join() 等语句里。
 - TIMED_WATING,有时限的等待另一个线程的特定操作。和WAITING的区别是wait() 等语句加上了时间限制 wait(timeout)。
 - TERMINATED,已退出的。

C、 jstat（JVM统计监测工具）
---

**jstat用来查看堆内存使用状况，一般结合jhat使用。**

语法格式如下：

jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]

常用`jstat -gcutil pid`

先看一下JVM堆内存布局：

![Jvm01]({{ '/styles/images/Jvm_tomcat/Jvm01.png' | prepend: site.baseurl  }})

可以看出：

堆内存 = 年轻代 + 年老代 + 永久代

年轻代 = Eden区 + 两个Survivor区（From和To）

现在来解释各列含义：

S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）

EC、EU：Eden区容量和使用量

OC、OU：年老代容量和使用量

PC、PU：永久代容量和使用量

YGC、YGT：年轻代GC次数和GC耗时

FGC、FGCT：Full GC次数和Full GC耗时

GCT：GC总耗时
